#!/usr/bin/env python

"""Minimalsite, a fast minimal static website builder. It generates web pages
from a file hierarchy with markdown and textile syntax."""

import os
import re
import sys
import string
import codecs
import argparse

try:
    import markdown
except ImportError:
    pass
try:
    import textile
except ImportError:
    pass

__author__      = "Marco Squarcina <lavish at gmail.com>"
__license__     = "MIT"
__copyright__   = "Copyright 2012, Marco Squarcina"
__status__      = "Development"
__version__     = "0.91"

# class definition

class Node:
    def __init__(self, src_pathname, level, parent = None):
        self.src_pathname = src_pathname
        self.dst_pathname = get_dst_pathname(src_pathname)
        self.src_file = os.path.basename(self.src_pathname)
        self.dst_file = os.path.basename(self.dst_pathname)
        self.name = get_name(self.dst_pathname)
        self.level = level
        self.parent = parent
        self.children = []

    def __str__(self):
        node = "<src_pathname: {}, dst_pathname: {}, src_file: {}, dst_file: {}, name: {}, level: {}>"
        return node.format(self.src_pathname, self.dst_pathname, self.src_file, self.dst_file, self.name, self.level)

    def add_child(self, obj):
        self.children.append(obj)


# functions definition

def syntax(pathname):
    """Returns the markup language used in the given pathname."""

    for lang in list(template.src_ext.keys()):
        if template.src_ext[lang] == pathname.split('.')[-1]:
                return lang

def hasindex(pathname):
    """Check if there's an index file in the given directory pathname."""

    for lang in list(template.src_ext.keys()):
        if os.path.isfile(pathname + "/index." + template.src_ext[lang]):
            return True
    return False

def get_dst_pathname(src_pathname):
    """Get destionation pathname from source pathname."""

    # replace extension
    dst_pathname = os.path.splitext(src_pathname)
    if dst_pathname[1]:
        dst_pathname = os.path.join(dst_pathname[0] + '.' + template.dst_ext)
    dst_pathname = ''.join(dst_pathname)
    # change destination dir
    dst_pathname = '/'.join(template.dst.split('/')
        + dst_pathname.split('/')[len(template.src.split('/')):])
    # remove index numbers for dirs and files
    return re.sub('\/\d+_', '/', dst_pathname)

def get_name(dst_pathname):
    """Get page name from destionation pathname."""

    name = os.path.basename(dst_pathname)
    name = os.path.splitext(name)[0]
    return name.replace('_', ' ')

def menu(node):
    """Given a node, returns a multine string of the menu code."""

    menu_code = "<ul>\n"
    for sibling in sorted(node.parent.children, key=lambda sibling: sibling.src_pathname):
        # and index page or a hidden file, no need to include them
        if sibling.dst_file.startswith("index.") or sibling.src_file in template.hidden:
            continue
        # a page
        elif not sibling.children:
            menu_code += '\t<li><a href="{}"'.format(sibling.dst_file)
            # current page
            if node == sibling:
                menu_code += ' class="current"'
            menu_code += '>{}</a></li>\n'.format(sibling.name)
        # a directory
        else:
            menu_code += '\t<li><a href="{}/index.{}">{}</a></li>\n'.format(sibling.dst_file, template.dst_ext, sibling.name)
    menu_code += "</ul>"
    return menu_code

def path(node):
    """Given a node, returns a string of the breadcrumb navigation path code."""
    
    path = ""
    path_node = []
    tmp_node = node
    while tmp_node:
        path_node.insert(0, tmp_node)
        tmp_node = tmp_node.parent
    # no need to display "index" in the path
    if path_node[-1].name == "index":
        path_node.pop()
    for i in range(0, len(path_node)):
        # last item, it could be current page or current dir
        if i == len(path_node) - 1:
            path += path_node[i].name
        # a parent page
        else:
            traversal = "../" * (node.level - path_node[i].level - 1)
            path += '<a href="{}index.{}">{}</a> {} '.format(traversal, template.dst_ext, path_node[i].name, template.path_separator)
    return path

def write_page(node):
    """Given a node, write on the file system its corresponding page."""

    # open source file
    h_src_pathname = codecs.open(node.src_pathname, "r", "utf-8");
    src_content = h_src_pathname.read()
    h_src_pathname.close()
    # build page
    dst_content = template.header(node)
    if(syntax(node.src_pathname) == "markdown"
    and "markdown" in template.src_ext):
        dst_content += markdown.markdown(src_content)
    elif(syntax(node.src_pathname) == "textile"
    and "textile" in template.src_ext):
        dst_content += textile.textile(src_content)
    elif(syntax(node.src_pathname) == "plain"
    and "plain" in template.src_ext):
        dst_content += src_content
    dst_content += template.footer(node)
    dst_content = dst_content.replace("%%%PATH%%%", path(node))
    dst_content = dst_content.replace("%%%MENU%%%", menu(node))
    # write destionation file
    h_dst_pathname = codecs.open(node.dst_pathname, "w", "utf-8")
    h_dst_pathname.write(dst_content)
    h_dst_pathname.close()

def print_tree(node, margin = ''):
    """Given a node, display the entire tree structure from that node."""

    if node:
        sys.stderr.write(margin + str(node) + "\n") 
        for child in node.children:
            print_tree(child, margin + '    ')

def build_tree(node):
    """Given a node, recursively create a tree representing the sources file
    hierarchy starting from that node."""

    for file in os.listdir(node.src_pathname):
        pathname = os.path.join(node.src_pathname, file)
        # do not add nodes for links and files starting with '.'
        if os.path.islink(pathname) or file[0] == ".":
            continue
        # add nodes for files with an allowed extension
        elif os.path.isfile(pathname) and syntax(pathname):
            node.add_child(Node(pathname, node.level + 1, node))
        # add nodes for directories and go on building the tree
        elif os.path.isdir(pathname) and hasindex(pathname):
            node.add_child(Node(pathname, node.level + 1, node))
            # -1 used to specify the last added node
            build_tree(node.children[-1])

def write_tree(node, margin = ''):
    """Given a node, recursively write all the corresponding pages on the file
    system."""

    # a directory
    if node.children:
        # create the destination dir, if possible
        try:
            os.makedirs(node.dst_pathname)
        except OSError:
            pass
        else:
            print(margin + "creating -> " + node.dst_pathname)
        # recursivly call write_tree against current node
        for child in node.children:
            write_tree(child, margin + '    ')
    # a file
    else:
        print(margin + "writing  -> " + node.dst_pathname)
        write_page(node)

def main():
    global template

    parser = argparse.ArgumentParser(description='Fast minimal static website builder')
    parser.add_argument('-V', '--verbose', action='store_true', default=False, help='display version')
    parser.add_argument('-t', '--template', type=str, default='default',
        help='specify a template: valid arguments are module names without path and extension')
    parser.add_argument('-s', '--src', type=str, default=None,
        help='source dir, where the textual hierarchy resides')
    parser.add_argument('-d', '--dst', type=str, default=None,
        help='destination dir, where the html pages will be written')
    parser.add_argument('-v', '--version', action='version', version='%(prog)s-'+__version__)
    args = parser.parse_args()

    # load template
    args.template = 'templates.' + args.template
    __import__(args.template)
    template = sys.modules[args.template]
    # check markup modules
    for markup in ('markdown', 'textile'):
        if not markup in sys.modules:
            del template.src_ext[markup]
    if not template.src_ext:
        sys.stderr.write("No modules for parsing files found. See README for requirements\n")
        sys.exit(3)
    # check src and dst directories
    if args.src:
        template.src = args.src
    if args.dst:
        template.dst = args.dst
    # fix trailing slashes
    template.src = os.path.abspath(template.src)
    template.dst = os.path.abspath(template.dst)
    for directory in [template.src, template.dst]:
        if not os.path.isdir(directory):
            sys.stderr.write('"' + directory + '" is not a directory, aborting\n')
            sys.exit(2)
    # check if src dir includes an index file
    if not hasindex(template.src):
        sys.stderr.write('"' + template.src + '" does not include a valid index file, aborting\n')
        sys.exit(2)
    # start writing pages
    print('Processing files in "' + template.src + '":\n')
    root = Node(template.src, 0)
    root.name = template.home
    build_tree(root)
    write_tree(root)
    print('\n... Done!')
    if args.verbose:
        sys.stderr.write("\nSite structure:\n\n")
        print_tree(root)

if __name__ == "__main__":
    main()
